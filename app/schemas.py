"""
Pydantic schemas for user data handling and validation.

These models define the structure and validation rules for
user data across the API, including creation, updates, and
response models.
"""
import re
from typing import Optional

from pydantic import (
    BaseModel,
    EmailStr,
    Field,
    ValidationInfo,
    field_validator
)

from .models import UserType 

# --- User Schemas ---

class UserBase(BaseModel):
    """
    Base schema for user properties.

    Shared attributes common to all user schemas, ensuring consistency
    in required and basic optional fields.
    """
    email: EmailStr = Field(..., description="The user's unique email address.")
    nickname: str = Field(
        ...,
        min_length=3,
        max_length=50,
        description="The user's unique nickname."
    )


class UserCreate(UserBase):
    """
    Schema for creating a new user.

    Extends UserBase by adding the required, validated password field.
    """
    password: str = Field(
        ...,
        min_length=8,
        description="The user's plain-text password."
    )

    @field_validator('password')
    @classmethod
    def validate_password(cls, v: str, info: ValidationInfo) -> str:
        """
        Validates the password complexity.

        Ensures the password meets minimum complexity requirements for security:
        must contain at least one uppercase letter, one lowercase letter, and one number.

        Args:
            v: The **plain-text password** string to validate.
            info: **Validator information** (unused here, but included for standard signature).

        Returns:
            str: The **validated password** if all checks pass.

        Raises:
            ValueError: If the password **does not meet** any of the complexity requirements.
        """
        if not re.search(r'[A-Z]', v):
            raise ValueError('Password must contain an uppercase letter')
        if not re.search(r'[a-z]', v):
            raise ValueError('Password must contain a lowercase letter')
        if not re.search(r'[0-9]', v):
            raise ValueError('Password must contain a number')
        return v


class UserUpdate(BaseModel):
    """
    Schema for updating an existing user.

    All fields are optional (`Optional[...]`), allowing for partial updates
    without requiring the client to send the entire user object.
    """
    email: Optional[EmailStr] = Field(
        None,
        description="The user's new email address."
    )
    nickname: Optional[str] = Field(
        None,
        min_length=3,
        max_length=50,
        description="The user's new nickname."
    )
    balance: Optional[float] = Field(
        None,
        ge=0,
        description="The user's updated balance."
    )
    user_type: Optional[UserType] = Field(
        None,
        description="The user's new role or type (e.g., admin, user)."
    )
    is_active: Optional[bool] = Field(
        None,
        description="Flag to activate or deactivate the user."
    )


class User(UserBase):
    """
    Schema for representing a user returned from the API (Response Model).
    """
    id: int = Field(..., description="The unique user ID generated by the database.")
    is_active: bool = Field(..., description="The activation status of the user.")
    balance: float = Field(..., description="The user's current monetary balance.")
    user_type: UserType = Field(..., description="The role or type of the user (e.g., UserType.ADMIN).")

    class Config:
        """Pydantic model configuration for ORM integration."""
        
        from_attributes: bool = True
        """
        Allows the Pydantic model to be created from ORM/SQLAlchemy model instances.
        """